# 排序

以下两个函数是排序中会用到的通用函数，就不一一写了
```
function checkArray(array) {
    if (!array || array.length <= 2) return
}
function swap(array, left, right) {
    let rightValue = array[right]
    array[right] = array[left]
    array[left] = rightValue
}
```

## 冒泡排序 

冒泡排序，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，

重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。

下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 length - 1 的位置。

以下是实现该算法的代码：
```
function bubble(array) {
  checkArray(array);
  for (let i = array.length - 1; i > 0; i--) {
    // 从 0 到 `length - 1` 遍历
    for (let j = 0; j < i; j++) {
      if (array[j] > array[j + 1]) swap(array, j, j + 1)
    }
  }
  return array;
}
```
该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n)


## 插入排序

插入排序，第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。
那么此时第一个元素就是当前的最小数，所以下次取出操作从第三个元素开始，向前对比，重复之前的操作。

以下是实现该算法的代码
```
function insertion(array) {
  checkArray(array);
  for (let i = 1; i < array.length; i++) {
    for (let j = i - 1; j >= 0 && array[j] > array[j + 1]; j--)
      swap(array, j, j + 1);
  }
  return array;
}
```
该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n)

## 希尔排序

希尔排序是在插入排序的基础上做的改进。

希尔排序通过将数组中部分元素逐步地变成有序的来提高插入排序的效率。
希尔排序是通过设置步长的方式让元素可以一次移动较长的距离来减少元素的移动次数来达到比插入排序更好的效果的。

首先设置一个初始的步长，将数组依据步长来分成多个子系列，
然后对每个子系列进行插入排序。
然后再逐步减小步长来使更多的数据变得有序，到步长为 1 的时候，执行最后一次插入排序。
这时候插入排序的效率会大大提升，因为数据中大部分数据都已经是有序的了。

```javascript
func shellSort<T:Comparable>(_ array:inout [T]){
    guard array.count > 1 else {
        return
    }
    
    var gap = array.count / 2
    
    while gap > 0 {
        
        for index in 0..<gap {
            
            insertionSort(&array, start: index, gap: gap)
        }
        gap = gap / 2
    }
}

func insertionSort<T:Comparable>(_ array:inout[T], start:Int, gap:Int) {
    for i in stride(from: start + gap, to: array.count, by: gap) {
        var pos = i
        let currentValue = array[i]
        
        while pos >= gap && array[pos - gap] > currentValue {
            array[pos] = array[pos - gap]
            pos -= gap
        }
        array[pos] = currentValue
    }
}
```

## 快速排序
选择一个数作为基准，将所有小于基准的数都放到左边，大于基准的数放到右边。
然后再递归地对基准左右两边的数据进行同样的计算，直到最后数组变成有序。

快速排序中，选择基准是很重要的。
基准选的好的话可以大大减少对比和交换的次数。
虽然快速排序在最差的时候可以到 O( n2 )，但是这个的概率非常低，快速排序的平均时间是 O( nlog(n) )。
```javascript
func quickSortLomuto<T:Comparable>(_ array:inout [T], low:Int, high:Int) {
   guard low < high else {
       return
   }
   
   let index = partitionLomuto(&array, low: low, high: high)
   quickSortLomuto(&array, low: low, high: index - 1)
   quickSortLomuto(&array, low: index + 1, high: high)
}

func partitionLomuto<T:Comparable>(_ array:inout [T], low:Int, high:Int) -> Int {
   let pivot = array[high]
   
   var i = low
   for j in low..<high {
       if array[j] <= pivot {
           (array[i], array[j]) = (array[j], array[i])
           i += 1
       }
   }
   (array[i], array[high]) = (array[high], array[i])
   return i
}
```

## 归并排序
归并排序是分治法的典型应用。
分治法的字面意思就是分而治之，就是把一个复杂的问题分成两个或者更多的相同或相似的子问题。

对于一个大数组来说，它是无序的，但是对于单个数据来说，它是有序的，
我们只要把有序的数据合并到一起，那么新的数据就还是有序的。

归并排序就是将数据分成一个个的小堆，然后两两合并堆中的数据，最后变成一个大的有序堆。

```javascript
func mergeSort<T:Comparable>(_ array: [T]) -> [T] {
   guard array.count > 1 else {
       return array
   }
   
   let middleIndex = array.count / 2
   
   let leftArray = mergeSort(Array(array[0..<middleIndex]))
   let rightArray = mergeSort(Array(array[middleIndex..<array.count]))

   return merge(leftArray, rightPile:rightArray)
}

func merge<T:Comparable>(_ leftPile:[T], rightPile:[T]) -> [T] {
   var leftIndex = 0
   var rightIndex = 0
   
   var orderedPile = [T]()
   
   while leftIndex < leftPile.count && rightIndex < rightPile.count {
       if leftPile[leftIndex] < rightPile[rightIndex] {
           orderedPile.append(leftPile[leftIndex])
           leftIndex += 1
       } else if leftPile[leftIndex] > rightPile[rightIndex] {
           orderedPile.append(rightPile[rightIndex])
           rightIndex += 1
       } else {
           orderedPile.append(leftPile[leftIndex])
           leftIndex += 1
           orderedPile.append(rightPile[rightIndex])
           rightIndex += 1
       }
   }
   
   while leftIndex < leftPile.count {
       orderedPile.append(leftPile[leftIndex])
       leftIndex += 1
   }
   
   while rightIndex < rightPile.count {
       orderedPile.append(rightPile[rightIndex])
       rightIndex += 1
   }
   return orderedPile
}
```